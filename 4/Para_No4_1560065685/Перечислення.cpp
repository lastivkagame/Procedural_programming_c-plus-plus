#include <iostream>
using namespace std;

int main()
{
	// Представимо задачу, що ми отримали напрямок, куди нам треба йти.
	// W - вперед, A - вліво, D - вправо, S - назад.

	char direction = 'S';

	switch (direction)
	{
	case 'w': case 'W':
		cout << "UP";
		break;
	case 's': case 'S':
		cout << "DOWN";
		break;
	case 'a': case 'A':
		cout << "LEFT";
		break;
	case 'd': case 'D':
		cout << "RIGHT";
		break;
	default:
		cout << "Incorrect direction";
		break;
	}
	cout << endl;

	// Що покращити цей код, було би добре, якби замість case'w': case 'W' було би
	// case UP. Ми можемо вирішити цю задачу через 4 константи:
	char direction2 = 'S';
	const char UP = 'W', DOWN = 'S', LEFT = 'A', RIGHT = 'D';

	switch (direction)
	{
	case UP:
		cout << "UP";
		break;
	case DOWN:
		cout << "DOWN";
		break;
	case LEFT:
		cout << "LEFT";
		break;
	case RIGHT:
		cout << "RIGHT";
		break;
	default:
		cout << "Incorrect direction";
		break;
	}
	cout << endl;

	// Але не зручно створювати 4 константи. Якби це був не напрямок а наприклад місяці року?
	// Робити 12 констант? А якщо я поміняю S на H, то це взагалі некоректний напрям.
	// Щоб спростити ось таке програмування, придумали перечислення (enumeration).

	// Перечислення - це ваш власний тип даних, який містить в собі цілочисельні іменовані константи.

	// Синтаксис створення перечислення:
	/*
	enum Ім'я_Перечислення { Список_Констант };
	*/

	// Приклад з напрямком:
	enum Direction { UP, DOWN, LEFT, RIGHT };

	// Створити перечислення недостатньо. Але ми можемо вже чимось користуватись. Наприклад константами.
	cout << "UP = " << UP << endl;       // на екрані 0
	cout << "DOWN = " << DOWN << endl;   // на екрані 1
	cout << "LEFT = " << LEFT << endl;   // на екрані 2
	cout << "RIGHT = " << RIGHT << endl; // на екрані 3

	// Коли ви створити перечислення, ви можете користуватись всіма константами з цього перечислення як
	// звичайними константами. Також можна замітити з прикладу, що якщо ви ЯВНО НЕ задаєте значення цим
	// константам, то ПЕРШІЙ константі дається значення 0, а кожній наступній на 1 більше за попередню.

	// Ми можемо звертатись до констант через перечислення:
	cout << "UP = " << Direction::UP << endl;       // на екрані 0
	cout << "DOWN = " << Direction::DOWN << endl;   // на екрані 1
	cout << "LEFT = " << Direction::LEFT << endl;   // на екрані 2
	cout << "RIGHT = " << Direction::RIGHT << endl; // на екрані 3

	// Тобто синтаксис звернення: Ім'я_Перечислення::Ім'я_Константи.
	// Я користуюсь таким варіантом по тій причині по-перше зрозуміліше, звідки константа,
	// а по-друге якщо у вас буде 2 перечислення, в який є константи з однаковим іменем, то варіант
	// без вказування ім'я перечислення приведе до помилки на етапі компіляції, бо компілятор не зрозуміє
	// яка саме константа вам треба.

	// Створимо ще одне перечислення, щоб ви побачити якій константі яке значення дасться:
	enum Month
	{
		JANUARY = 1, // 1
		FEBRUARY,    // 2
		MARCH,       // 3
		APRIL,       // 4
		MAY,         // 5
		JUNE,        // 6
		JULY,        // 7
		AUGUST,      // 8
		SEPTEMBER,   // 9
		OCTOBER,     // 10
		NOVEMBER,    // 11
		DECEMBER     // 12
	};

	// Але оскільки перечислення - це ТИП, то можна створювати змінні цього перечислення так само, як
	// і любі інші змінні.

	// Синтаксис створення змінної перечислення: 
	// 1) Ім'я_Перечислення Ім'я_Змінної;
	// 2) Ім'я_Перечислення Ім'я_Змінної = Значення;

	// Знаючи це все, давайте вирішимо задачу з напрямком
	Direction direction3 = Direction::UP;
	switch (direction3)
	{
	case Direction::UP:
		cout << "UP";
		break;
	case Direction::DOWN:
		cout << "DOWN";
		break;
	case Direction::LEFT:
		cout << "LEFT";
		break;
	case Direction::RIGHT:
		cout << "RIGHT";
		break;
	}

	// Тепер все виглядає в рази зрозуміліше.

	// Але змінна перечислення дає нам ще одну перевагу:
	direction3 = 5;

	// Тут помилка на етапі компіляції, бо число 5 не є типом перечислення. Це дає вам додаткову безпеку.
	// Але завдяки явному приведенню можна обійти це.
	direction3 = Direction(5); // без поняття, що туди може записатись. Не робіть так, якщо не треба.

	return 0;
}