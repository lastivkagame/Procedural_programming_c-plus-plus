#include <iostream>
using namespace std;

int main()
{
	// Якщо ви не знаєте що таке масиви, то перейдіть спочатку в інший файл.

	// Бувають ситуації, коли сразу при створені масиву треба його елементи заповнити початковими даними.
	// Наприклад у мене є жінка і 2 дітей. Я хочу створити масив, в який запишу вагу кожного з нас.
	// Я знаю вагу всіх членів моєї сім'ї. Я хочу написати програму, в яку я буду вносити корективи по вазі.
	// Але ж спочатку всі ваги відомі, тому я хочу заповнити масив початковими значеннями. Як це зробити?
	// Я можу скористатись банальним прийомом:
	const int MEMBERS = 4;
	double weight[MEMBERS];
	weight[0] = 79.32; // представимо що 0 елементов є я
	weight[1] = 59.90; // це моя жінка
	weight[2] = 32.50; // це моя молодша дитина
	weight[3] = 41.20; // а це старша дитина

	// Виглядає начебто і зручно, але є варіант простіший - спискова ініціалізація. Завдяки ній ми можемо
	// задати елементам масиву значення зразу при його створені.

	// Синтаксис спискової ініціалізації:
	// 1) Тип_Даних Ім'я_Масиву[Кількість_Елементів] = { Список_Значень };
	// 2) Тип_Даних Ім'я_Масиву[Кількість_Елементів] { Список_Значень };

	// Перший варіант від другого відрізняється наявністю "=". Обидва варіанти еквівалентні, але я вибираю
	// перший, бо він мені виглядає чіткішим. Знаючи це, давайте "перестворимо" масив.
	double weight[MEMBERS] = { 79.32, 59, 90, 32.50 };

	// Тепер кожному елементу задасться відповідне значення, тільки я все це зробив в одному рядку. Спискова ініціалізація
	// дуже корисна і популярна. Ви будете ще нею користуватись часто. Але вона має ще одну "плюшку". Гляньте на цей код:
	int arr[3];
	cout << arr[0]; // Що тут виведе? 

	// Нічого, бо буде помилка на етапі компіляції. Ви ж знаєте, що якщо звичайна змінна не має значення, то в неї записується "сміття"
	// якесь значення, яке записує компілятор. Поки там зберігається сміття, ви не можете користуватись цією змінною. Вам треба спочатку задати
	// їй значення. Так от, елемент масиву - це також змінна і там також записується сміття. 

	// Спискова ініціалізація захищає елементи від сміття, розберемо всі можливі варіанти:
	int arr1[3] = { 1, 2, 3 };    // все добре
	int arr2[3] = { 1, 2, 3, 4 }; // помилка. Занадто багато елементів в списку
	int arr3[3] = { 1, 2 };       // все добре. Перші 2 елемента отримують значення, останній отримує 0! (вже не сміття)
	cout << arr3[2]; // 0
	int arr4[10] = { 10 };        // все добре. Перший елемент отримує 10, всі інші 0.
	int arr5[50] = {};            // все добре. Всі елементи отримують 0.

	// Може у вас виникнуть соблазн заповнити не перші елементи а через один, наприклад ось так:
	int arr6[4] = { , 2, 4 }; // так робити не можна.

	// Виникає питання: а можна задати значення лише конкретному елементу а інші обнулити? Чи обов'язково все починається зліва-направо?
	// Відповідь проста: не можна, тому що немає задач в яких дійсно це ТАК ТРЕБА ЩО БЕЗ ЦЬОГО НІЯК.

	// Якщо ви використовуєте спискову ініціалізацію, то розмір масиву можна не вказувати, компілятор сам порахує кількість елементів
	int arr7[] = { 1, 2, 3, 4, 5 }; // 5 елементів
	// Але якщо це не масив-рядок (вчитимете пізніше), то толку від цього мало, бо ви все одно будете використовувати цикли, де треба буде писати розмір масиву.

	return 0;
}