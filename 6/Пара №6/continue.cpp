#include <iostream>
using namespace std;

int main()
{
	// В мові С++ є оператор continue, який застосовується ЛИШЕ в циклах.
	// Наприклад в 3 наступних прикладах у вас буде помилка на етапі компіляції:
	
	continue; // помилка. Оператор не находиться в циклах

	if (true)
	{
		continue; // помилка. Оператор не находиться в циклах
	}

	int num = 1;
	switch (num)
	{
	case 1:
		continue; // помилка. Оператор не находиться в циклах
	}

	// Цей оператор треба застосовувати в циклах. Що ж він робить?
	// Якщо брати професійний термін, то завдяки оператору continue
	// программа переходить на наступної ітерації в циклі.

	// Ітерація - це дія, яку виконує цикл. Наприклад:
	for (int i = 0; i < 3; i++)
	{
		cout << i << " ";
		cout << i * i << endl;
	}

	// При першій ітерації на екран виведеться 0 0.
	// При другій ітерації на екран виведеться 1 1
	// При третій ітерації на екран виведеться 2 4

	// Тобто ітерація - це просто все що находиться в фігурних дужках циклу.
	// Так от, глянемо наступний код

	for (int i = 0; i < 5; i++)
	{
		if (i == 2)
			continue;

		cout << i << " ";
		cout << i * i << endl;
	}

	// Що тут буде робитись. Давайте аналізувати по ітераціям.
	// Ітеріація №1: і == 0, отже на екрані 0 0.
	// Ітеріація №2: і == 1, отже на екрані 1 1.
	// Ітеріація №3: і == 2, отже спрацьовує if. Оператор continue ПЕРЕКИДАЄ виконання програми
	//               зразу до розділу зміни лічильника, в нашому випадку до "і++".
	// Ітеріація №4: і == 3, отже на екрані 3 9.
	// Ітеріація №5: і == 4, отже на екрані 4 16.

	// Тобто з роботи коду має стати зрозміло, що continue робить схожу роботу з break. Тільки
	// break ЗУПИНЯЄ роботу конструкції (циклу чи switch), а continue заставляє программу перейти
	// до наступної ітерації МИТТЄВО.

	// Якщо ви прийшли сюди після ознайомлення з break і for (а було би добре, якби так і було), то
	// ви мали прочитати, що for відрізняється від while/do while також і роботою цього оператора.
	// Давайте перепишемо цю задачу через while:
	int i = 0;
	while (i < 5)
	{
		if (i == 2)
			continue;

		cout << i << " ";
		cout << i * i << endl;
		i++;
	}

	// Аналізуємо що робиться тут:
	// Ітеріація №1: і == 0, отже на екрані 0 0.
	// Ітеріація №2: і == 1, отже на екрані 1 1.
	// Ітеріація №3: і == 2, отже спрацьовує if. Оператор continue ПЕРЕКИДАЄ виконання програми
	//               зразу до УМОВИ, бо в циклі while немає розділу зміни лічильника.
	// Ітеріація №4: і == 2, отже спрацьовує if. Оператор continue ЗНОВУ перекидає виконання програми
	//               зразу до умови.
	// Ітеріація №5: і == 2, і знову перекидає.
	// Ітеріація №6: і == 2, і знову... І так вічно.

	// Звідси випливає друга відмінність між циклом while і for: оператор continue перекидає виконання
	// програми в циклі while до умови, а в циклі  for до зміни лічильника

	// Для чого і де треба оператор continue? Любу задачу, де він використовується, можна переписати без нього.
	// Наприкад ось цей код:
	for (int i = 0; i < 5; i++)
	{
		if (i == 2)
			continue;

		cout << i << " ";
		cout << i * i << endl;
	}

	// Можна переписати ось так:
	for (int i = 0; i < 5; i++)
	{
		if (i != 2)
		{
			cout << i << " ";
			cout << i * i << endl;
		}
	}

	// І все буде працювати аналогічно. Але появляється вкладена область. В деяких випадках вона
	// може бути дуже глибокою, що буде заважати простоті кода. Любу задачу, де використовується continue,
	// можна зробити без нього, але його створення придумане з простою ціллю - покращити читання коду.
	// Особисто я його дуже рідко використовую, тому що задачі, де він треба, дуже специфічні.
	// Тобто оператори break і continue в циклах створені лише для того, щоб спрощувати код і не більше.
	// Якщо захочете використати оператор continue, то знайте що задачу можна зробити і без нього. В такому
	// разі зробіть задачу через різний код (з continue і без) і подивіться де код виглядає зрозумілішим.

	return 0;
}