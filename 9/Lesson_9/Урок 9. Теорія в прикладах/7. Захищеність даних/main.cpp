#include <iostream>
using namespace std;

//Коли функція описується, то вона може створити як свої змінні, так і константи в параметрах
void FuncA(int funcVariable);
void FuncB(const int funcConstant); //замітьте, функція при її виклику створить константу. Значення цієї константи
                                    //буде тим, яке відправиться при її виклику.

//Але це не означає, що у функцію треба посилати константу

int main()
{
	int myVariable = 10;
	const int myConstant = 20;

	//Замітьте, оскільки передача у функції йде по ЗНАЧЕННЮ, то туди можна передавати
	//і константи і змінні.
	FuncA(myVariable); //У функцію надсилається значення змінної (10).
	                   //Функція створить власну змінну, значення якої 10
	FuncA(myConstant); //У функцію надсилається значення константи (20).
					   //Функція створить власну змінну, значення якої 20

	FuncB(myVariable); //У функцію надсилається значення змінної (10).
					   //Функція створить власну константу, значення якої 10
	FuncB(myConstant); //У функцію надсилається значення константи (20).
					   //Функція створить власну константу, значення якої 20

	//Основна суть цього проекту не в цій інформації, а в тому, що багато програмістів вважають
	//непотрібним робити параметри функції константними. Що дає нам константність? Наведу приклад:
	//Написати функцію, яка виводить масив на екран. Дуже просто. Давайте напишемо прототип:
	void Show(int arr[], int size); 

	//Зауваження: да, прототипи можна писати і у функціях, але це робиться надзвичайно рідко. Чому
	//            можна так робити? Це приховує передчасний виклик функції. Тобто функцію можна викликати
	//            лише з тої функції, де находиться її прототип. Але ми відійшли від теми.

	//Реалізуємо цю функцію (переходьте на рядок №57)

	system("pause");
	return 0;
}

void FuncA(int funcVariable)
{
	cout << "I have own variable. Her value = " << funcVariable << endl;
}

void FuncB(const int funcConstant)
{
	cout << "I have own constant. Her value = " << funcConstant << endl;
}

//Спочатку перейдіть до рядка №28.
void Show(int arr[], int size)
{
	//Дивіться, які можуть виникнути проблеми в цій функції:
	size = -2; //ви або інший програміст можете (випадково) змінити значення змінної розміру.
	           //І все. Цикл працювати не буде

	arr[size - 1] = 5; //також можна (випадково) змінити значення елементу масиву перед тим, як вивести.
	                   //суть функції лише у виводі масиву, але в ній чогось може помінятися елемент

	//Вам здається, що допустити такі помилки нереально. На прикладі масиву це дійсно так. Але краще
	//зараз почати розвивати в собі цю звичку, ніж щоб колись, коли ви писатимете величезні функції, і десь допустите
	//помилку (наприклад зачепите значення якоїсь незначної змінної, із-за чого програма працюватиме некоректно),
	//то знатимете, як її вирішити. Допишіть в параметрах функції класифікатори const, і ви побачите, як компілятор
	//вам підкреслить помилки. З цього моменту я слідкуватиму за тим, щоб ви це робили. Багато програмістів це не
	//роблять, бо не вважають за потрібне (бо також думають, що це нереально), але це реально і це добавить
	//елегантність і безпеку у ваш код. В цьому і суть захищенності данних.

	//Зауваження: добре думайте, де ставити константи, а де ні. Наприклад при виводі масиву - логічно що у всіх параметрах.
	//            А якщо треба заповнити масив рандомними значеннями? Тоді логічно, що масив залишаємо без класифікатора
	//            const, а його розмір залишаємо константим. З часом ви самі бачитимете, куди ліпити ці класифікатори

	//основна робота функції. Погодьтеся, вона має бути справною
	for (size_t i = 0; i < size; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;

	//Прохання: я раніше казав, що константи називаємо лише великими буквами. Але коли ви перетворюєте
	//          параметр функції в константний, не треба писати його назву великими буквами. Ви ж знаєте
	//          що const зробить цей параметр захищеним від змінни, тим не менше у функцію може посилатися
	//          не обов'язково константа.
}