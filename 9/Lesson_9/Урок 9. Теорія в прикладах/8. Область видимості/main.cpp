#include <iostream>
using namespace std;

//А зараз вирішимо декілька серйозних питань:
//1. Чому можна в різних функціях змінним давати однакові імена?
//2. Чому після роботи циклу for знищується та змінна, яку ми в ньому створюємо?
//3. Чому якщо ми створюємо змінну де небуть (if,while,for), то вона знищується після їх роботи?

//Для початку відійдемо трохи далеко від цього. Почнемо з того, що змінні можна створювати не тільки
//у функціях. Їх можна створювати і поза ними. Такі змінні/константи/масиви називаються глобальними.
int OutVariable;               //глобальна змінна
const int OutConst;            //глоабльна константа
int OutVariableArray[3];       //глобальний масив з 3 змінних
const int OutConstantArray[3]; //глоабльний масив з 3 констант

//Зауваження: якщо ви створюєте змінні/константи/масиви глобально і не задаєте їм значення, то
//            їм задаються значення за замовчуванням (нулі). Саме тому в рядках №12 і №14 задавати значення
//            не обов'язково константам.

//Що нам дають ці глобальні об'єкти? Те, що їх бачить кожна функція. Тобто їх область видимості - в межах усього
//файлу. Гляньте:
void Func1()
{
	//ця функція бачить глобальну змінну
	cout << "Global variable = " << OutVariable << endl;

	//і може її міняти
	OutVariable = 20;
	cout << "Global variable = " << OutVariable << endl;

	//А всі об'єкти (змінні/константи/масиви), які ви створюєте у функціях, називаються автоматичними або локальними.
	//Локальними тому, що їх область видимості є локальною по відношенню до тієї функції, де вони створені:
	int localVariable = 20; //перейдіть до рядка №36
}

void Func2()
{
	//хоч люба функція бачить глобальні об'єкти, але вона не бачить локальні об'єкти інших функцій:
	cout << localVariable << endl; //помилка. Ця функція не бачить цієї змінної і не знає, чи вона взагалі існує.

	//А чому локальні об'єкти називають ще автоматичними? Тому що ці об'єкти автоматично знищуються, коли функція
	//закінчує свою роботу:
	int localVariable = 20; //ідентичний рядок до рядка №33. А тепер перейдіть до рядка №46
}

int main()
{
	//Функція main, як і всі інші функції, також бачить глобальні об'єкти
	cout << "I see a global constant: " << OutConst << endl;

	int localVariable = 20; //створимо ще один ідентичний рядок до рядка №33.

	//Оскільки робота програми починається з функції main, то спочатку виконується її код. Насправді це не зовсім
	//коректно. Спочатку створюються всі глобальні об'єкти. І знищуються вони тільки, коли програма закінчує свою роботу.
	//Потім (в даному випадку) створюється змінна на рядку №51. Окей, викликаємо функцію:
	Func1();

	//Ця функція створює свою локальну змінну? Чому нема помилки із-за однакових назв змінних? Тому що змінна на рядку №51
	//видна лише всередині функції main. А змінна на рядку №33 видна лише у функції Func1. Ці функції не знають про тіла
	//одна одної. Вони між собою можуть спілкуватись лише завдяки надсилаючим параметрам і поверненням значення. Тому
	//помилки не виникає.

	//З цим розібрались. Тобто ми вже знаємо глобальну область видимості (об'єкт находиться поза функціями)
	//і локальну (об'єкт находиться у функції). Які є ще?

	//Область видимості блоку:
	int a = 10;
	if (a == 10)
	{
		int b = 5; //змінна b створилась в блоці оператора if (його блок формують фігурні дужки). Це значить
				   //що коли програма дойде до рядка, наступного за закриваючою дужкою цього оператора - всі об'єкти
				   //які, створились в ньому знищаться. Тобто на рядку №74 змінна b існувати вже не буде.
	}
	cout << b << endl; //змінної b вже не існує. Вона знищилась.
	int b = 2;         //це означає, що змінну з назвою "b" ми можемо заново створювати (ім'я то вже вільне)

	//А це нас веде до розгадки цикла for:
	for (int i = 0; i < 5; i++)
	{
		//Як тільки виконання програми дійшло до циклу, створюється змінна "i"
	}

	//після закінчення циклу вона знищується, тому що область її видимості - блок циклу for. 
	cout << i << endl; //помилка. Змінної вже не існує

	//Тому далі ми можемо спокійно використовувати в іншому циклі це ім'я (і не тільки в циклі)
	for (int i = 0; i < 10; i++)
	{
		//створилась знову змінна "і" і знову знищиться після роботи циклу
	}

	//В допитливих студентів може виникнути питання: що буде, якщо я напишу ось так?
	int c = 10;
	if (c == 10)
	{
		int c = 2;
		c = 10;
	}
	cout << c << endl; //що тут взагалі відбується і яке значення виведеться на екран?

	//Перед тим, як я це поясню, спробуйте самі розібрати код, як можете

	//Пояснення: перше, що влітає в голову - чому немає помилки імен? Адже і там і там є
	//           змінна з іменем "с". Що відбувається? В такому разі, коли виконання програми
	//           находиться всередині фігурних дужок (в даному випадку) і створюється змінна "с",
	//           то змінна "с" з рядка №93 (зовнішня) приховується. Це означає, що поки не закінчеться
	//           робота блоку, ми не зможемо вернутись до змінної "с" з рядка №93. Звідси слідує
	//           що в рядка №97 ми міняємо значення змінної в рядку №96. Тобто тепер "с" рівна не 2 а 10.
	//           Як тільки блок закінчується (рядок №98) - внутрішня змінна "с" (рядок №96) знищується.
	//           В рядку №99 виводиться значення 10 (тобто значення змінної із рядка №93).

	//Така же робота і з глобальними об'єктами:
	int OutVariable; //локальна змінна з таким же ім'ям, що і глобальна змінна в рядку №11. На етапі виконання
					 //програми на цьому рядку глобальна змінна "приховуються" до того моменту поки функція
					 //main не закінчить свою роботу (в даному випадку).

	//Бонус: можна створювати свої області видимості де хочете. Робиться це дуже просто:

	//Завдяки простим фігурним дужкам створюємо область видимості
	{
		int my = 10; //в ній створюємо що хочемо
	}
	//після закінчення роботи в цій області все що там створено - знищиться
	cout << my << endl;

	//Зауваження №1: нагадую, що якщо ви даєте ім'я локальній змінній, то прийнято перше слово починати
	//               з малої букви, всі інші - з великої. В імені глоабльної змінної всі слова починаються з
	//               великої букви

	//Зауваження №2: глобальні змінні часто застосовувались в мові С. В мові С++ багато хто рекомендує їх уникати
	//               тому що вони плутають код. Як, ви поки що не можете зрозуміти. Коротко поясню - коли у вас є
	//               20 .cpp файлів - важко відслідкувати, де створюється глобальна змінна, і де вона змінюється.
	//               На цьому проблеми не закінчуються. Глобальна змінна видима лише в межах файлу, де вона створена.
	//               Щоб її бачили інші файли, треба застосовувати спеціальне ключове слово, і за ним також треба
	//               слідкувати. Уникайте глобальних змінних (ми з ними попрацюємо на практиці, щоб закріпити знання
	//               і цього буде досить).

	//Зауваження №3: створюйте свої області видимості якомога поменше. Вони псують читабельність коду.
	system("pause");
	return 0;
}